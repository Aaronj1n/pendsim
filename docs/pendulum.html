<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>pendulum.pendulum API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pendulum.pendulum</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.text as text
from matplotlib.gridspec import GridSpec
from matplotlib.animation import FuncAnimation
from math import sin, cos, pi
from scipy.integrate import solve_ivp

class Pendulum(object):
    &#39;&#39;&#39;
    An inverted pendulum object.
    &#39;&#39;&#39;
    def __init__(self, M, m, l, g, init_state=(0,0,0,0)):
        &#39;&#39;&#39;
        Parameters
        ----------

        M: float
            The cart mass
        m: float
            The pendulum mass
        l: float
            The pendulum length
        g: float
            Acceleration due to gravity
        &#39;&#39;&#39;
        self.M = M
        self.m = m
        self.l = l
        self.g = g
        self.E = 0 #: current energy (kinetic plus potential)
        self.xdd = 0 #: current xddot (linear acceleration cart)
        self.tdd = 0 #: current thetaddot (angular acceleration pendulum)
        self.init_state = init_state
    
    def calculate_accel(self, state, u):
        &#39;&#39;&#39;
        Update accelerations xddot, thetaddot from current state, given an input force.

        Parameters
        ----------
        u: float
            Force on the cart pointing right, in newtons.
        
        Returns
        -------
        (float, float)
            xdd and thetadd (the acceleration)
        &#39;&#39;&#39;
        # state =   [x, xdot, theta, thetadot]
        sin_t = np.sin(state[2])
        cos_t = np.cos(state[2])

        # A^-1     2x2
        A = np.linalg.inv(
            np.array([
            [self.M + self.m,       -self.m * self.l * cos_t],
            [-cos_t,                self.l]
            ])
        )

        # B  2 @ 1
        B = np.array([
            [-self.m*self.l*state[3]*state[3] * sin_t + u],
            [self.g * sin_t]
        ])

        solution = A @ B
        xdd = solution[0][0]
        tdd = solution[1][0]
        return (xdd, tdd)

    def pend_update(self, state, dt, u):
        &#39;&#39;&#39;
        Given the current state, timestep, and force applied, updates the pendulum state over that timestep.

        Parameters
        ----------
        state: (float, float, float, float)
            The current state
        dt: float
            The length of the update step (seconds, I guess?)
        u: float
            The force
        
        Returns
        -------
        (float, float, float, float)
            The new state after time interval dt [x, xdot, theta, thetadot]
        &#39;&#39;&#39;
        # update acceleration xddot_k, thddot_k = f(x_k, u_k)
        (xdd, tdd) = self.calculate_accel(state, u)
        # write accelerations
        self.xdd = xdd
        self.tdd = tdd

        # Euler method, x_k+1 = x_k + xdot_k * dt
        x = state[0] + state[1] * dt
        xd = state[1] + xdd * dt
        t = state[2] + state[3] * dt
        td = state[3] + tdd * dt

        return (x, xd, t, td)


    def calculate_state_energy(self, state):
        &#39;&#39;&#39;
        Calculate the energy of the current state

        Parameters
        ----------
        state: (float, float, float, float)
            The current state

        Returns
        -------
        (float float):
            The kinetic and potential energy of the current state
        &#39;&#39;&#39;
        # cart vel. squared
        v_c2 = state[1] * state[1] 
        # pendulum velocity squared
        v_p2 = v_c2 - 2 * self.l * state[1] * state[3] * np.cos(state[2]) + self.l * self.l * state[3] * state[3]

        KE = 0.5 * self.M * v_c2 + .5 * self.m * v_p2
        PE = self.m * self.g * self.l * np.cos(state[2])

        return (KE, PE)

    def calculate_momentum(self, state):
        &#39;&#39;&#39;
        Calculate the (x-direction) linear momentum of the current state.

        Paramters
        ---------
        state: (float, float, float, float)
            The current state

        Returns
        -------
        (float, float):
            The current momentums of the cart and the pendulum.
        &#39;&#39;&#39;
        p_cart = self.M * state[1] 
        p_pend = self.m * (state[1] + state[3] * np.sin(state[2]))
        return (p_cart, p_pend)

class Simulation(object):
    &#39;&#39;&#39;
    The simulation object.
    &#39;&#39;&#39;
    def __init__(self, pendulum, dt, t_final, u):
        &#39;&#39;&#39;
        Parameters
        ----------
        pendulum: `Pendulum`
            The pendulum to be simulated
        dt: float
            The time step of the simulation
        t_final: float
            Simulate up to this time
        u: list of (float, float, float)
            List of force magnitude, start time, and end time pairs.
        k: int
            The kth simulation timestep, starting from 0.
        times: [int]
            List of simulation times of length k.
        data: dict
            Dictionary containing the simulation data. Keys are the attribute,
            values are the data at each step of the simulation.
        &#39;&#39;&#39;
        self.pendulum = pendulum
        self.dt = dt
        self.t_final = t_final
        self.u = u
        self.k = 0
        self.times = []
        self.data={
            &#39;x&#39;: [], 
            &#39;xdot&#39;: [],
            &#39;xdd&#39; : [],
            &#39;theta&#39;:[],
            &#39;thetadot&#39;:[],
            &#39;tdd&#39;: [],
            &#39;PE&#39;:[], 
            &#39;KE&#39;:[], 
            &#39;E&#39;:[], 
            &#39;cart momentum&#39;: [],
            &#39;pendulum momentum&#39;: [], 
            &#39;total momentum&#39;: [],
            &#39;forces&#39; : []}
    
    def simulate(self):
        &#39;&#39;&#39;
        Run the simulation.

        Returns
        -------
        pandas.DataFrame
            Dataframe containing simulation data, indexed by time.
        &#39;&#39;&#39;
        t = 0
        state = pendulum.init_state
        while t &lt;= self.t_final:
            # record the current state, energies, etc.
            self.times.append(t)
            self.data[&#39;x&#39;].append(state[0])
            self.data[&#39;xdot&#39;].append(state[1])
            self.data[&#39;xdd&#39;].append(self.pendulum.xdd)
            self.data[&#39;theta&#39;].append(state[2])
            self.data[&#39;thetadot&#39;].append(state[3])
            self.data[&#39;tdd&#39;].append(self.pendulum.tdd)
            self.data[&#39;KE&#39;].append(self.pendulum.calculate_state_energy(state)[0])
            self.data[&#39;PE&#39;].append(self.pendulum.calculate_state_energy(state)[1])
            self.data[&#39;E&#39;].append(self.pendulum.calculate_state_energy(state)[0] + self.pendulum.calculate_state_energy(state)[1])
            p_cart, p_pend = self.pendulum.calculate_momentum(state)
            self.data[&#39;cart momentum&#39;].append(p_cart) 
            self.data[&#39;pendulum momentum&#39;].append(p_pend)
            self.data[&#39;total momentum&#39;].append(p_cart + p_pend)

            # add up all present forces
            u_k = 0
            for force in self.u:
                f_begin = force[1]
                f_end = force[1] + force[2]
                if f_begin &lt; t &lt; f_end:
                    u_k+= force[0]
            self.data[&#39;forces&#39;].append(u_k)
            
            # update state
            state = pendulum.pend_update(state, self.dt, u_k)
            t += self.dt

        return pd.DataFrame(index=self.times, data=self.data)

class Visualizer(object):
    &#39;&#39;&#39;
    Visualizer object is what we use to visualize the animated pendulum as well as display plots.
    &#39;&#39;&#39;
    def __init__(self, data, pendulum, frameskip=1, save=False, cart_display_width=2, cart_height=1, viz_size=(10,10), viz_window_size=(16, 9)):
        &#39;&#39;&#39;
        Parameters
        ----------
        data : pandas.DataFrame
            The data from the simulation
        pendulum : `Pendulum`
            The pendulum that is visualized
        frameskip : int, default 1
            The number of calculated time intervals to skip. Setting frameskip 
            to 1 will show every frame, 3 will show only every 3rd frame, etc. 
            This allows to run the animation at faster than real time speed.
        save : bool, default False
            Whether to save the animation. Saving requires ffmpeg to function.
        cart_display_width : float, default 1
            The display width of the cart as it appears on the animation.
        cart_height : float, default 1
            The display height of the cart as it appears on the animation.
        viz_size : (float, float)
            The size of the visualized canvas
        viz_window_size : (float, float)
            The size of the visualization window (or of the video once rendered)
        &#39;&#39;&#39;
        self.data = data
        self.pendulum = pendulum
        self.frameskip = frameskip
        self.save = save
        self.cart_display_width = cart_display_width
        self.cart_height = cart_height 
        self.viz_size = viz_size 
        self.viz_window_size = viz_window_size

    def display_viz(self):
        &#39;&#39;&#39;
        Display (show) the animated visualization. This function calls plt.show()

        Returns
        -------
        None
        &#39;&#39;&#39;
        viz = plt.figure(figsize=self.viz_window_size)
        ax = plt.axes()
        plt.axis(&#39;scaled&#39;)
        ax.set_xlim(-self.viz_size[0], self.viz_size[0])
        ax.set_ylim(-self.viz_size[1], self.viz_size[1])
        cart = patches.Rectangle((-self.cart_display_width * 0.5, self.cart_height), width=self.cart_display_width, height=-self.cart_height, ec=&#39;black&#39;, fc=&#39;seagreen&#39;)
        mass = patches.Circle((0,0), radius=np.sqrt(5)*0.14, fc=&#39;skyblue&#39;, ec=&#39;black&#39;)
        line = patches.FancyArrow(0,0,1,1)
        force = patches.FancyArrow(0,0,1,1, ec=&#39;red&#39;)
        time_text = text.Annotation(&#39;&#39;, (4,4), xycoords=&#39;axes points&#39;)
        ground = patches.Rectangle((-1000, -2000), 2000, 2000, fc=&#39;lightgrey&#39;)
        ax.add_patch(ground)

        def init():
            ax.add_patch(cart)
            ax.add_patch(mass)
            ax.add_patch(line)
            ax.add_artist(time_text)
            ax.add_patch(force)
            return [mass, cart, time_text, line, force]

        # matplotlib animate doesn&#39;t play nice with dataframes :(
        animate_x = data[&#39;x&#39;].values.tolist()[::self.frameskip]
        animate_theta = data[&#39;theta&#39;].values.tolist()[::self.frameskip]
        animate_force = data[&#39;forces&#39;].values.tolist()[::self.frameskip]
        animate_times = data.index.values.tolist()[::self.frameskip]
        frames = len(animate_times)

        def animate(i):
            x = -animate_x[i] # position
            th = animate_theta[i] # angle
            u = animate_force[i] # force
            massxy = (x + self.pendulum.l * np.sin(th), self.cart_height + self.pendulum.l * np.cos(th))
            cartxy_visible = (x - self.cart_display_width*.5, self.cart_height)
            # animate force application
            if u &gt; 0.0:
                force_begin = (x + .5 * self.cart_display_width, .5 * self.cart_height)
                force_end = (x + .5 * self.cart_display_width + np.sqrt(.1*u), .5 * self.cart_height)
                force.set_xy((force_begin, force_end))
                force.set_linewidth(np.sqrt(u))
                force.set_visible(True)
            elif u &lt; 0.0:
                force_begin = (x - .5 * self.cart_display_width, .5 * self.cart_height)
                force_end = (x - .5 * self.cart_display_width - np.sqrt(.1*np.abs(u)), .5 * self.cart_height)
                force.set_xy((force_begin, force_end))
                force.set_linewidth(np.sqrt(np.abs(u)))
                force.set_visible(True)
            else: 
                force.set_visible(False)

            cartxy_true = (x, self.cart_height)
            mass.set_center(massxy)
            cart.set_xy(cartxy_visible)
            line.set_xy((massxy, cartxy_true))
            time_text.set_text(&#34;t=&#34;+str(animate_times[i]))
            return [mass, cart, time_text, line, force]
        animation = FuncAnimation(viz, animate, frames, init_func=init, blit=True, interval=32)
        if self.save:
            animation.save(&#39;video.mp4&#39;, fps=30)
        plt.show()
    
    def display_plots(self):
        &#39;&#39;&#39;
        Return a figure containing the plots, which can then be saved or displayed.

        Returns
        -------
        `matplotlib.pyplot.figure`
        &#39;&#39;&#39;
        figure = plt.figure()
        ax0 = figure.add_subplot(411)
        ax1 = figure.add_subplot(412)
        ax2 = figure.add_subplot(413)
        ax3 = figure.add_subplot(414)
        ax0.plot(self.data[&#39;x&#39;],label=r&#39;$x$&#39;)
        ax1.plot(self.data[&#39;xdot&#39;],label=r&#39;$\dot{x}$&#39;)
        ax0.plot(self.data[&#39;theta&#39;],label=r&#39;$\theta$&#39;)
        ax1.plot(self.data[&#39;thetadot&#39;],label=r&#39;$\dot{\theta}$&#39;)
        ax1.plot(self.data[&#39;xdd&#39;],label=r&#39;xdd&#39;)
        ax1.plot(self.data[&#39;tdd&#39;],label=r&#39;tdd&#39;)
        ax1.legend()
        # ax2.plot(self.data[&#39;cart momentum&#39;], label=&#39;cart momentum&#39;)
        # ax2.plot(self.data[&#39;pendulum momentum&#39;], label=&#39;pendulum momentum&#39;)
        # ax2.plot(self.data[&#39;total momentum&#39;], label=&#39;total momentum&#39;)
        ax2.plot(self.data[&#39;PE&#39;], label=&#39;PE&#39;)
        ax2.plot(self.data[&#39;KE&#39;], label=&#39;KE&#39;)
        ax2.plot(self.data[&#39;E&#39;], label=&#39;E&#39;)
        ax2.legend()
        ax3.plot(self.data[&#39;forces&#39;], label=&#39;force&#39;)

        return figure


if __name__ == &#34;__main__&#34;:
    forces = [
        (50, 1, 0.5),
        (-100, 10, 0.5),
        (-50, 16, .5),
        (200, 19, .25)
    ]
    pendulum = Pendulum(15,2,3,9.81, np.array([0,0,0.1,0]))
    sim = Simulation(pendulum, .001, 30, forces)
    data = sim.simulate()
    plot = Visualizer(data, pendulum, frameskip=32, save=False, viz_size=(20,8), viz_window_size=(16,9))
    plot.display_viz()
    plot.display_plots()
    plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pendulum.pendulum.Pendulum"><code class="flex name class">
<span>class <span class="ident">Pendulum</span></span>
<span>(</span><span>M, m, l, g, init_state=(0, 0, 0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>An inverted pendulum object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code>float</code></dt>
<dd>The cart mass</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>float</code></dt>
<dd>The pendulum mass</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>The pendulum length</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>float</code></dt>
<dd>Acceleration due to gravity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pendulum(object):
    &#39;&#39;&#39;
    An inverted pendulum object.
    &#39;&#39;&#39;
    def __init__(self, M, m, l, g, init_state=(0,0,0,0)):
        &#39;&#39;&#39;
        Parameters
        ----------

        M: float
            The cart mass
        m: float
            The pendulum mass
        l: float
            The pendulum length
        g: float
            Acceleration due to gravity
        &#39;&#39;&#39;
        self.M = M
        self.m = m
        self.l = l
        self.g = g
        self.E = 0 #: current energy (kinetic plus potential)
        self.xdd = 0 #: current xddot (linear acceleration cart)
        self.tdd = 0 #: current thetaddot (angular acceleration pendulum)
        self.init_state = init_state
    
    def calculate_accel(self, state, u):
        &#39;&#39;&#39;
        Update accelerations xddot, thetaddot from current state, given an input force.

        Parameters
        ----------
        u: float
            Force on the cart pointing right, in newtons.
        
        Returns
        -------
        (float, float)
            xdd and thetadd (the acceleration)
        &#39;&#39;&#39;
        # state =   [x, xdot, theta, thetadot]
        sin_t = np.sin(state[2])
        cos_t = np.cos(state[2])

        # A^-1     2x2
        A = np.linalg.inv(
            np.array([
            [self.M + self.m,       -self.m * self.l * cos_t],
            [-cos_t,                self.l]
            ])
        )

        # B  2 @ 1
        B = np.array([
            [-self.m*self.l*state[3]*state[3] * sin_t + u],
            [self.g * sin_t]
        ])

        solution = A @ B
        xdd = solution[0][0]
        tdd = solution[1][0]
        return (xdd, tdd)

    def pend_update(self, state, dt, u):
        &#39;&#39;&#39;
        Given the current state, timestep, and force applied, updates the pendulum state over that timestep.

        Parameters
        ----------
        state: (float, float, float, float)
            The current state
        dt: float
            The length of the update step (seconds, I guess?)
        u: float
            The force
        
        Returns
        -------
        (float, float, float, float)
            The new state after time interval dt [x, xdot, theta, thetadot]
        &#39;&#39;&#39;
        # update acceleration xddot_k, thddot_k = f(x_k, u_k)
        (xdd, tdd) = self.calculate_accel(state, u)
        # write accelerations
        self.xdd = xdd
        self.tdd = tdd

        # Euler method, x_k+1 = x_k + xdot_k * dt
        x = state[0] + state[1] * dt
        xd = state[1] + xdd * dt
        t = state[2] + state[3] * dt
        td = state[3] + tdd * dt

        return (x, xd, t, td)


    def calculate_state_energy(self, state):
        &#39;&#39;&#39;
        Calculate the energy of the current state

        Parameters
        ----------
        state: (float, float, float, float)
            The current state

        Returns
        -------
        (float float):
            The kinetic and potential energy of the current state
        &#39;&#39;&#39;
        # cart vel. squared
        v_c2 = state[1] * state[1] 
        # pendulum velocity squared
        v_p2 = v_c2 - 2 * self.l * state[1] * state[3] * np.cos(state[2]) + self.l * self.l * state[3] * state[3]

        KE = 0.5 * self.M * v_c2 + .5 * self.m * v_p2
        PE = self.m * self.g * self.l * np.cos(state[2])

        return (KE, PE)

    def calculate_momentum(self, state):
        &#39;&#39;&#39;
        Calculate the (x-direction) linear momentum of the current state.

        Paramters
        ---------
        state: (float, float, float, float)
            The current state

        Returns
        -------
        (float, float):
            The current momentums of the cart and the pendulum.
        &#39;&#39;&#39;
        p_cart = self.M * state[1] 
        p_pend = self.m * (state[1] + state[3] * np.sin(state[2]))
        return (p_cart, p_pend)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pendulum.pendulum.Pendulum.calculate_accel"><code class="name flex">
<span>def <span class="ident">calculate_accel</span></span>(<span>self, state, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Update accelerations xddot, thetaddot from current state, given an input force.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>float</code></dt>
<dd>Force on the cart pointing right, in newtons.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(float, float)
xdd and thetadd (the acceleration)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_accel(self, state, u):
    &#39;&#39;&#39;
    Update accelerations xddot, thetaddot from current state, given an input force.

    Parameters
    ----------
    u: float
        Force on the cart pointing right, in newtons.
    
    Returns
    -------
    (float, float)
        xdd and thetadd (the acceleration)
    &#39;&#39;&#39;
    # state =   [x, xdot, theta, thetadot]
    sin_t = np.sin(state[2])
    cos_t = np.cos(state[2])

    # A^-1     2x2
    A = np.linalg.inv(
        np.array([
        [self.M + self.m,       -self.m * self.l * cos_t],
        [-cos_t,                self.l]
        ])
    )

    # B  2 @ 1
    B = np.array([
        [-self.m*self.l*state[3]*state[3] * sin_t + u],
        [self.g * sin_t]
    ])

    solution = A @ B
    xdd = solution[0][0]
    tdd = solution[1][0]
    return (xdd, tdd)</code></pre>
</details>
</dd>
<dt id="pendulum.pendulum.Pendulum.calculate_momentum"><code class="name flex">
<span>def <span class="ident">calculate_momentum</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the (x-direction) linear momentum of the current state.</p>
<h2 id="paramters">Paramters</h2>
<p>state: (float, float, float, float)
The current state</p>
<h2 id="returns">Returns</h2>
<p>(float, float):
The current momentums of the cart and the pendulum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_momentum(self, state):
    &#39;&#39;&#39;
    Calculate the (x-direction) linear momentum of the current state.

    Paramters
    ---------
    state: (float, float, float, float)
        The current state

    Returns
    -------
    (float, float):
        The current momentums of the cart and the pendulum.
    &#39;&#39;&#39;
    p_cart = self.M * state[1] 
    p_pend = self.m * (state[1] + state[3] * np.sin(state[2]))
    return (p_cart, p_pend)</code></pre>
</details>
</dd>
<dt id="pendulum.pendulum.Pendulum.calculate_state_energy"><code class="name flex">
<span>def <span class="ident">calculate_state_energy</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the energy of the current state</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>(float, float, float, float)</code></dt>
<dd>The current state</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(float float):
The kinetic and potential energy of the current state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_state_energy(self, state):
    &#39;&#39;&#39;
    Calculate the energy of the current state

    Parameters
    ----------
    state: (float, float, float, float)
        The current state

    Returns
    -------
    (float float):
        The kinetic and potential energy of the current state
    &#39;&#39;&#39;
    # cart vel. squared
    v_c2 = state[1] * state[1] 
    # pendulum velocity squared
    v_p2 = v_c2 - 2 * self.l * state[1] * state[3] * np.cos(state[2]) + self.l * self.l * state[3] * state[3]

    KE = 0.5 * self.M * v_c2 + .5 * self.m * v_p2
    PE = self.m * self.g * self.l * np.cos(state[2])

    return (KE, PE)</code></pre>
</details>
</dd>
<dt id="pendulum.pendulum.Pendulum.pend_update"><code class="name flex">
<span>def <span class="ident">pend_update</span></span>(<span>self, state, dt, u)</span>
</code></dt>
<dd>
<div class="desc"><p>Given the current state, timestep, and force applied, updates the pendulum state over that timestep.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>(float, float, float, float)</code></dt>
<dd>The current state</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the update step (seconds, I guess?)</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>float</code></dt>
<dd>The force</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(float, float, float, float)
The new state after time interval dt [x, xdot, theta, thetadot]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pend_update(self, state, dt, u):
    &#39;&#39;&#39;
    Given the current state, timestep, and force applied, updates the pendulum state over that timestep.

    Parameters
    ----------
    state: (float, float, float, float)
        The current state
    dt: float
        The length of the update step (seconds, I guess?)
    u: float
        The force
    
    Returns
    -------
    (float, float, float, float)
        The new state after time interval dt [x, xdot, theta, thetadot]
    &#39;&#39;&#39;
    # update acceleration xddot_k, thddot_k = f(x_k, u_k)
    (xdd, tdd) = self.calculate_accel(state, u)
    # write accelerations
    self.xdd = xdd
    self.tdd = tdd

    # Euler method, x_k+1 = x_k + xdot_k * dt
    x = state[0] + state[1] * dt
    xd = state[1] + xdd * dt
    t = state[2] + state[3] * dt
    td = state[3] + tdd * dt

    return (x, xd, t, td)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pendulum.pendulum.Simulation"><code class="flex name class">
<span>class <span class="ident">Simulation</span></span>
<span>(</span><span>pendulum, dt, t_final, u)</span>
</code></dt>
<dd>
<div class="desc"><p>The simulation object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pendulum</code></strong> :&ensp;<code><a title="pendulum.pendulum.Pendulum" href="#pendulum.pendulum.Pendulum">Pendulum</a></code></dt>
<dd>The pendulum to be simulated</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>The time step of the simulation</dd>
<dt><strong><code>t_final</code></strong> :&ensp;<code>float</code></dt>
<dd>Simulate up to this time</dd>
<dt><strong><code>u</code></strong> :&ensp;<code>list</code> of <code>(float, float, float)</code></dt>
<dd>List of force magnitude, start time, and end time pairs.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>The kth simulation timestep, starting from 0.</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>[int]</code></dt>
<dd>List of simulation times of length k.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing the simulation data. Keys are the attribute,
values are the data at each step of the simulation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulation(object):
    &#39;&#39;&#39;
    The simulation object.
    &#39;&#39;&#39;
    def __init__(self, pendulum, dt, t_final, u):
        &#39;&#39;&#39;
        Parameters
        ----------
        pendulum: `Pendulum`
            The pendulum to be simulated
        dt: float
            The time step of the simulation
        t_final: float
            Simulate up to this time
        u: list of (float, float, float)
            List of force magnitude, start time, and end time pairs.
        k: int
            The kth simulation timestep, starting from 0.
        times: [int]
            List of simulation times of length k.
        data: dict
            Dictionary containing the simulation data. Keys are the attribute,
            values are the data at each step of the simulation.
        &#39;&#39;&#39;
        self.pendulum = pendulum
        self.dt = dt
        self.t_final = t_final
        self.u = u
        self.k = 0
        self.times = []
        self.data={
            &#39;x&#39;: [], 
            &#39;xdot&#39;: [],
            &#39;xdd&#39; : [],
            &#39;theta&#39;:[],
            &#39;thetadot&#39;:[],
            &#39;tdd&#39;: [],
            &#39;PE&#39;:[], 
            &#39;KE&#39;:[], 
            &#39;E&#39;:[], 
            &#39;cart momentum&#39;: [],
            &#39;pendulum momentum&#39;: [], 
            &#39;total momentum&#39;: [],
            &#39;forces&#39; : []}
    
    def simulate(self):
        &#39;&#39;&#39;
        Run the simulation.

        Returns
        -------
        pandas.DataFrame
            Dataframe containing simulation data, indexed by time.
        &#39;&#39;&#39;
        t = 0
        state = pendulum.init_state
        while t &lt;= self.t_final:
            # record the current state, energies, etc.
            self.times.append(t)
            self.data[&#39;x&#39;].append(state[0])
            self.data[&#39;xdot&#39;].append(state[1])
            self.data[&#39;xdd&#39;].append(self.pendulum.xdd)
            self.data[&#39;theta&#39;].append(state[2])
            self.data[&#39;thetadot&#39;].append(state[3])
            self.data[&#39;tdd&#39;].append(self.pendulum.tdd)
            self.data[&#39;KE&#39;].append(self.pendulum.calculate_state_energy(state)[0])
            self.data[&#39;PE&#39;].append(self.pendulum.calculate_state_energy(state)[1])
            self.data[&#39;E&#39;].append(self.pendulum.calculate_state_energy(state)[0] + self.pendulum.calculate_state_energy(state)[1])
            p_cart, p_pend = self.pendulum.calculate_momentum(state)
            self.data[&#39;cart momentum&#39;].append(p_cart) 
            self.data[&#39;pendulum momentum&#39;].append(p_pend)
            self.data[&#39;total momentum&#39;].append(p_cart + p_pend)

            # add up all present forces
            u_k = 0
            for force in self.u:
                f_begin = force[1]
                f_end = force[1] + force[2]
                if f_begin &lt; t &lt; f_end:
                    u_k+= force[0]
            self.data[&#39;forces&#39;].append(u_k)
            
            # update state
            state = pendulum.pend_update(state, self.dt, u_k)
            t += self.dt

        return pd.DataFrame(index=self.times, data=self.data)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pendulum.pendulum.Simulation.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the simulation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>Dataframe containing simulation data, indexed by time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self):
    &#39;&#39;&#39;
    Run the simulation.

    Returns
    -------
    pandas.DataFrame
        Dataframe containing simulation data, indexed by time.
    &#39;&#39;&#39;
    t = 0
    state = pendulum.init_state
    while t &lt;= self.t_final:
        # record the current state, energies, etc.
        self.times.append(t)
        self.data[&#39;x&#39;].append(state[0])
        self.data[&#39;xdot&#39;].append(state[1])
        self.data[&#39;xdd&#39;].append(self.pendulum.xdd)
        self.data[&#39;theta&#39;].append(state[2])
        self.data[&#39;thetadot&#39;].append(state[3])
        self.data[&#39;tdd&#39;].append(self.pendulum.tdd)
        self.data[&#39;KE&#39;].append(self.pendulum.calculate_state_energy(state)[0])
        self.data[&#39;PE&#39;].append(self.pendulum.calculate_state_energy(state)[1])
        self.data[&#39;E&#39;].append(self.pendulum.calculate_state_energy(state)[0] + self.pendulum.calculate_state_energy(state)[1])
        p_cart, p_pend = self.pendulum.calculate_momentum(state)
        self.data[&#39;cart momentum&#39;].append(p_cart) 
        self.data[&#39;pendulum momentum&#39;].append(p_pend)
        self.data[&#39;total momentum&#39;].append(p_cart + p_pend)

        # add up all present forces
        u_k = 0
        for force in self.u:
            f_begin = force[1]
            f_end = force[1] + force[2]
            if f_begin &lt; t &lt; f_end:
                u_k+= force[0]
        self.data[&#39;forces&#39;].append(u_k)
        
        # update state
        state = pendulum.pend_update(state, self.dt, u_k)
        t += self.dt

    return pd.DataFrame(index=self.times, data=self.data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pendulum.pendulum.Visualizer"><code class="flex name class">
<span>class <span class="ident">Visualizer</span></span>
<span>(</span><span>data, pendulum, frameskip=1, save=False, cart_display_width=2, cart_height=1, viz_size=(10, 10), viz_window_size=(16, 9))</span>
</code></dt>
<dd>
<div class="desc"><p>Visualizer object is what we use to visualize the animated pendulum as well as display plots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The data from the simulation</dd>
<dt><strong><code>pendulum</code></strong> :&ensp;<code><a title="pendulum.pendulum.Pendulum" href="#pendulum.pendulum.Pendulum">Pendulum</a></code></dt>
<dd>The pendulum that is visualized</dd>
<dt><strong><code>frameskip</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>The number of calculated time intervals to skip. Setting frameskip
to 1 will show every frame, 3 will show only every 3rd frame, etc.
This allows to run the animation at faster than real time speed.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Whether to save the animation. Saving requires ffmpeg to function.</dd>
<dt><strong><code>cart_display_width</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>The display width of the cart as it appears on the animation.</dd>
<dt><strong><code>cart_height</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>The display height of the cart as it appears on the animation.</dd>
<dt><strong><code>viz_size</code></strong> :&ensp;<code>(float, float)</code></dt>
<dd>The size of the visualized canvas</dd>
<dt><strong><code>viz_window_size</code></strong> :&ensp;<code>(float, float)</code></dt>
<dd>The size of the visualization window (or of the video once rendered)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visualizer(object):
    &#39;&#39;&#39;
    Visualizer object is what we use to visualize the animated pendulum as well as display plots.
    &#39;&#39;&#39;
    def __init__(self, data, pendulum, frameskip=1, save=False, cart_display_width=2, cart_height=1, viz_size=(10,10), viz_window_size=(16, 9)):
        &#39;&#39;&#39;
        Parameters
        ----------
        data : pandas.DataFrame
            The data from the simulation
        pendulum : `Pendulum`
            The pendulum that is visualized
        frameskip : int, default 1
            The number of calculated time intervals to skip. Setting frameskip 
            to 1 will show every frame, 3 will show only every 3rd frame, etc. 
            This allows to run the animation at faster than real time speed.
        save : bool, default False
            Whether to save the animation. Saving requires ffmpeg to function.
        cart_display_width : float, default 1
            The display width of the cart as it appears on the animation.
        cart_height : float, default 1
            The display height of the cart as it appears on the animation.
        viz_size : (float, float)
            The size of the visualized canvas
        viz_window_size : (float, float)
            The size of the visualization window (or of the video once rendered)
        &#39;&#39;&#39;
        self.data = data
        self.pendulum = pendulum
        self.frameskip = frameskip
        self.save = save
        self.cart_display_width = cart_display_width
        self.cart_height = cart_height 
        self.viz_size = viz_size 
        self.viz_window_size = viz_window_size

    def display_viz(self):
        &#39;&#39;&#39;
        Display (show) the animated visualization. This function calls plt.show()

        Returns
        -------
        None
        &#39;&#39;&#39;
        viz = plt.figure(figsize=self.viz_window_size)
        ax = plt.axes()
        plt.axis(&#39;scaled&#39;)
        ax.set_xlim(-self.viz_size[0], self.viz_size[0])
        ax.set_ylim(-self.viz_size[1], self.viz_size[1])
        cart = patches.Rectangle((-self.cart_display_width * 0.5, self.cart_height), width=self.cart_display_width, height=-self.cart_height, ec=&#39;black&#39;, fc=&#39;seagreen&#39;)
        mass = patches.Circle((0,0), radius=np.sqrt(5)*0.14, fc=&#39;skyblue&#39;, ec=&#39;black&#39;)
        line = patches.FancyArrow(0,0,1,1)
        force = patches.FancyArrow(0,0,1,1, ec=&#39;red&#39;)
        time_text = text.Annotation(&#39;&#39;, (4,4), xycoords=&#39;axes points&#39;)
        ground = patches.Rectangle((-1000, -2000), 2000, 2000, fc=&#39;lightgrey&#39;)
        ax.add_patch(ground)

        def init():
            ax.add_patch(cart)
            ax.add_patch(mass)
            ax.add_patch(line)
            ax.add_artist(time_text)
            ax.add_patch(force)
            return [mass, cart, time_text, line, force]

        # matplotlib animate doesn&#39;t play nice with dataframes :(
        animate_x = data[&#39;x&#39;].values.tolist()[::self.frameskip]
        animate_theta = data[&#39;theta&#39;].values.tolist()[::self.frameskip]
        animate_force = data[&#39;forces&#39;].values.tolist()[::self.frameskip]
        animate_times = data.index.values.tolist()[::self.frameskip]
        frames = len(animate_times)

        def animate(i):
            x = -animate_x[i] # position
            th = animate_theta[i] # angle
            u = animate_force[i] # force
            massxy = (x + self.pendulum.l * np.sin(th), self.cart_height + self.pendulum.l * np.cos(th))
            cartxy_visible = (x - self.cart_display_width*.5, self.cart_height)
            # animate force application
            if u &gt; 0.0:
                force_begin = (x + .5 * self.cart_display_width, .5 * self.cart_height)
                force_end = (x + .5 * self.cart_display_width + np.sqrt(.1*u), .5 * self.cart_height)
                force.set_xy((force_begin, force_end))
                force.set_linewidth(np.sqrt(u))
                force.set_visible(True)
            elif u &lt; 0.0:
                force_begin = (x - .5 * self.cart_display_width, .5 * self.cart_height)
                force_end = (x - .5 * self.cart_display_width - np.sqrt(.1*np.abs(u)), .5 * self.cart_height)
                force.set_xy((force_begin, force_end))
                force.set_linewidth(np.sqrt(np.abs(u)))
                force.set_visible(True)
            else: 
                force.set_visible(False)

            cartxy_true = (x, self.cart_height)
            mass.set_center(massxy)
            cart.set_xy(cartxy_visible)
            line.set_xy((massxy, cartxy_true))
            time_text.set_text(&#34;t=&#34;+str(animate_times[i]))
            return [mass, cart, time_text, line, force]
        animation = FuncAnimation(viz, animate, frames, init_func=init, blit=True, interval=32)
        if self.save:
            animation.save(&#39;video.mp4&#39;, fps=30)
        plt.show()
    
    def display_plots(self):
        &#39;&#39;&#39;
        Return a figure containing the plots, which can then be saved or displayed.

        Returns
        -------
        `matplotlib.pyplot.figure`
        &#39;&#39;&#39;
        figure = plt.figure()
        ax0 = figure.add_subplot(411)
        ax1 = figure.add_subplot(412)
        ax2 = figure.add_subplot(413)
        ax3 = figure.add_subplot(414)
        ax0.plot(self.data[&#39;x&#39;],label=r&#39;$x$&#39;)
        ax1.plot(self.data[&#39;xdot&#39;],label=r&#39;$\dot{x}$&#39;)
        ax0.plot(self.data[&#39;theta&#39;],label=r&#39;$\theta$&#39;)
        ax1.plot(self.data[&#39;thetadot&#39;],label=r&#39;$\dot{\theta}$&#39;)
        ax1.plot(self.data[&#39;xdd&#39;],label=r&#39;xdd&#39;)
        ax1.plot(self.data[&#39;tdd&#39;],label=r&#39;tdd&#39;)
        ax1.legend()
        # ax2.plot(self.data[&#39;cart momentum&#39;], label=&#39;cart momentum&#39;)
        # ax2.plot(self.data[&#39;pendulum momentum&#39;], label=&#39;pendulum momentum&#39;)
        # ax2.plot(self.data[&#39;total momentum&#39;], label=&#39;total momentum&#39;)
        ax2.plot(self.data[&#39;PE&#39;], label=&#39;PE&#39;)
        ax2.plot(self.data[&#39;KE&#39;], label=&#39;KE&#39;)
        ax2.plot(self.data[&#39;E&#39;], label=&#39;E&#39;)
        ax2.legend()
        ax3.plot(self.data[&#39;forces&#39;], label=&#39;force&#39;)

        return figure</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pendulum.pendulum.Visualizer.display_plots"><code class="name flex">
<span>def <span class="ident">display_plots</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a figure containing the plots, which can then be saved or displayed.</p>
<h2 id="returns">Returns</h2>
<p><code>matplotlib.pyplot.figure</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_plots(self):
    &#39;&#39;&#39;
    Return a figure containing the plots, which can then be saved or displayed.

    Returns
    -------
    `matplotlib.pyplot.figure`
    &#39;&#39;&#39;
    figure = plt.figure()
    ax0 = figure.add_subplot(411)
    ax1 = figure.add_subplot(412)
    ax2 = figure.add_subplot(413)
    ax3 = figure.add_subplot(414)
    ax0.plot(self.data[&#39;x&#39;],label=r&#39;$x$&#39;)
    ax1.plot(self.data[&#39;xdot&#39;],label=r&#39;$\dot{x}$&#39;)
    ax0.plot(self.data[&#39;theta&#39;],label=r&#39;$\theta$&#39;)
    ax1.plot(self.data[&#39;thetadot&#39;],label=r&#39;$\dot{\theta}$&#39;)
    ax1.plot(self.data[&#39;xdd&#39;],label=r&#39;xdd&#39;)
    ax1.plot(self.data[&#39;tdd&#39;],label=r&#39;tdd&#39;)
    ax1.legend()
    # ax2.plot(self.data[&#39;cart momentum&#39;], label=&#39;cart momentum&#39;)
    # ax2.plot(self.data[&#39;pendulum momentum&#39;], label=&#39;pendulum momentum&#39;)
    # ax2.plot(self.data[&#39;total momentum&#39;], label=&#39;total momentum&#39;)
    ax2.plot(self.data[&#39;PE&#39;], label=&#39;PE&#39;)
    ax2.plot(self.data[&#39;KE&#39;], label=&#39;KE&#39;)
    ax2.plot(self.data[&#39;E&#39;], label=&#39;E&#39;)
    ax2.legend()
    ax3.plot(self.data[&#39;forces&#39;], label=&#39;force&#39;)

    return figure</code></pre>
</details>
</dd>
<dt id="pendulum.pendulum.Visualizer.display_viz"><code class="name flex">
<span>def <span class="ident">display_viz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display (show) the animated visualization. This function calls plt.show()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_viz(self):
    &#39;&#39;&#39;
    Display (show) the animated visualization. This function calls plt.show()

    Returns
    -------
    None
    &#39;&#39;&#39;
    viz = plt.figure(figsize=self.viz_window_size)
    ax = plt.axes()
    plt.axis(&#39;scaled&#39;)
    ax.set_xlim(-self.viz_size[0], self.viz_size[0])
    ax.set_ylim(-self.viz_size[1], self.viz_size[1])
    cart = patches.Rectangle((-self.cart_display_width * 0.5, self.cart_height), width=self.cart_display_width, height=-self.cart_height, ec=&#39;black&#39;, fc=&#39;seagreen&#39;)
    mass = patches.Circle((0,0), radius=np.sqrt(5)*0.14, fc=&#39;skyblue&#39;, ec=&#39;black&#39;)
    line = patches.FancyArrow(0,0,1,1)
    force = patches.FancyArrow(0,0,1,1, ec=&#39;red&#39;)
    time_text = text.Annotation(&#39;&#39;, (4,4), xycoords=&#39;axes points&#39;)
    ground = patches.Rectangle((-1000, -2000), 2000, 2000, fc=&#39;lightgrey&#39;)
    ax.add_patch(ground)

    def init():
        ax.add_patch(cart)
        ax.add_patch(mass)
        ax.add_patch(line)
        ax.add_artist(time_text)
        ax.add_patch(force)
        return [mass, cart, time_text, line, force]

    # matplotlib animate doesn&#39;t play nice with dataframes :(
    animate_x = data[&#39;x&#39;].values.tolist()[::self.frameskip]
    animate_theta = data[&#39;theta&#39;].values.tolist()[::self.frameskip]
    animate_force = data[&#39;forces&#39;].values.tolist()[::self.frameskip]
    animate_times = data.index.values.tolist()[::self.frameskip]
    frames = len(animate_times)

    def animate(i):
        x = -animate_x[i] # position
        th = animate_theta[i] # angle
        u = animate_force[i] # force
        massxy = (x + self.pendulum.l * np.sin(th), self.cart_height + self.pendulum.l * np.cos(th))
        cartxy_visible = (x - self.cart_display_width*.5, self.cart_height)
        # animate force application
        if u &gt; 0.0:
            force_begin = (x + .5 * self.cart_display_width, .5 * self.cart_height)
            force_end = (x + .5 * self.cart_display_width + np.sqrt(.1*u), .5 * self.cart_height)
            force.set_xy((force_begin, force_end))
            force.set_linewidth(np.sqrt(u))
            force.set_visible(True)
        elif u &lt; 0.0:
            force_begin = (x - .5 * self.cart_display_width, .5 * self.cart_height)
            force_end = (x - .5 * self.cart_display_width - np.sqrt(.1*np.abs(u)), .5 * self.cart_height)
            force.set_xy((force_begin, force_end))
            force.set_linewidth(np.sqrt(np.abs(u)))
            force.set_visible(True)
        else: 
            force.set_visible(False)

        cartxy_true = (x, self.cart_height)
        mass.set_center(massxy)
        cart.set_xy(cartxy_visible)
        line.set_xy((massxy, cartxy_true))
        time_text.set_text(&#34;t=&#34;+str(animate_times[i]))
        return [mass, cart, time_text, line, force]
    animation = FuncAnimation(viz, animate, frames, init_func=init, blit=True, interval=32)
    if self.save:
        animation.save(&#39;video.mp4&#39;, fps=30)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pendulum" href="index.html">pendulum</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pendulum.pendulum.Pendulum" href="#pendulum.pendulum.Pendulum">Pendulum</a></code></h4>
<ul class="">
<li><code><a title="pendulum.pendulum.Pendulum.calculate_accel" href="#pendulum.pendulum.Pendulum.calculate_accel">calculate_accel</a></code></li>
<li><code><a title="pendulum.pendulum.Pendulum.calculate_momentum" href="#pendulum.pendulum.Pendulum.calculate_momentum">calculate_momentum</a></code></li>
<li><code><a title="pendulum.pendulum.Pendulum.calculate_state_energy" href="#pendulum.pendulum.Pendulum.calculate_state_energy">calculate_state_energy</a></code></li>
<li><code><a title="pendulum.pendulum.Pendulum.pend_update" href="#pendulum.pendulum.Pendulum.pend_update">pend_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pendulum.pendulum.Simulation" href="#pendulum.pendulum.Simulation">Simulation</a></code></h4>
<ul class="">
<li><code><a title="pendulum.pendulum.Simulation.simulate" href="#pendulum.pendulum.Simulation.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pendulum.pendulum.Visualizer" href="#pendulum.pendulum.Visualizer">Visualizer</a></code></h4>
<ul class="">
<li><code><a title="pendulum.pendulum.Visualizer.display_plots" href="#pendulum.pendulum.Visualizer.display_plots">display_plots</a></code></li>
<li><code><a title="pendulum.pendulum.Visualizer.display_viz" href="#pendulum.pendulum.Visualizer.display_viz">display_viz</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>